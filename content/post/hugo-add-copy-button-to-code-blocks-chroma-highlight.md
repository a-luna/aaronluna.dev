---
title: 'Hugo: Add Copy-to-Clipboard Button to Code Blocks with Vanilla JS'
slug: hugo-add-copy-button-to-code-blocks-chroma-highlight
date: '2019-11-13'
categories:
  - Hugo
  - JavaScript
summary: "Hugo includes a built-in syntax-highlighter called Chroma. Chroma is extremely fast since it is written
in pure Go (like Hugo) and supports every language I can think of. Chroma's speed is especially important since
syntax highlighters are notorious for causing slow page loads. However, it lacks one vital feature â€” an easy way
to copy a code block to the clipboard. Check out my implementation that uses only vanilla JS (every blog post I
found for this issue relied on jquery to parse the DOM, which makes me sick to my stomach)."
twitter:
  card: "summary"
  creator: "@aaronlunadev"
  title: "How To: Create a Flask API with JWT-Based Authentication"
  description: "Step-by-step instructions and in-depth explanations to guide you through the process of creating a robust, production-quality REST API using Flask, Flask-RESTlus, pyjwt, SQLAlchemy and more."
  image: "https://aaronluna.dev/img/flask-api-tutorial/p04-02-swagger-ui-auth.jpg"
---

I am currently working on a multi-part tutorial series that demonstrates how to create a REST API using Flask, SQLAlchemy and various other tools/packages. After instructing the reader to <span class="bold-italics">"copy the text below and paste into file blah blah"</span> for the eightieth time I realized that asking someone to select an entire block of text from a `code` element, and then copy and paste it is an annoying and error-prone process. It's also unnecessary! Even the most rudimentary and humble of blog posts have code blocks with a button that copies the code to the clipboard.

A quick search led me to <a href="https://www.dannyguo.com/blog/how-to-add-copy-to-clipboard-buttons-to-code-blocks-in-hugo/" target="_blank">this post</a> on Danny Guo's blog. I used his example as my starting point but made several changes:

<ul>
  <li>The "copy" button is placed within the code block rather than outside it.</li>
  <li>My implementation uses the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API" target="_blank">Clipboard API</a> if the user's browser supports it. However, since it is not yet widely supported, my script falls back to using <code>document.execCommand("copy")</code> if it is unesupported or the `clipboard-write` permission has not been granted.</li>
  <li>"Copy" buttons are only added to <code>code</code> elements that are generated by Chroma.</li>
</ul>

The <a href="https://gohugo.io/content-management/syntax-highlighting/" target="_blank">Hugo highlight shortcode</a> accepts a `line-nos` parameter. If `line-nos` is not specified or `line-nos=inline`, the rendered HTML has this structure:

```html
<div class="highlight">
  <pre class="chroma">
    <code class="language-xxxx">
      (the code we wish to copy)
    </code>
  </pre>
</div>
```

If `line-nos=table`, the HTML is slightly more complicated:

```html
<div class="highlight">
  <div class="chroma">
    <table class="lntable">
      <tbody>
        <tr>
          <td class="lntd">
            (the line numbers are rendered here)
          </td>
          <td class="lntd">
            <pre class="chroma">
              <code class="language-xxxx">
                (the code we wish to copy)
              </code>
            </pre>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>
```

I use the version with line numbers much more often than the version without, so it is important to me to support both. I decided to place the button inside the <code class="chroma"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">"highlight"</span><span class="p">&gt;</span></code> element. Stacking elements on top of one another requires positioning and assigning `z-index` values, which you can see below along with the styling for the "copy" button:

```css
.highlight-wrapper {
  display: block;
  margin: 0 0 1em 0;
}

.highlight {
  position: relative;
  z-index: 0;
  padding: 0;
  margin: 0;
}

.highlight > .chroma {
  position: static;
  z-index: 1;
}

.copy-code-button {
  position: absolute;
  z-index: 2;
  right: 0;
  font-size: 13px;
  font-weight: 700;
  color: #202020;
  background-color: #57b6ff;
  border: 1px solid #57b6ff;
  border-radius: 4px;
  white-space: nowrap;
  padding: 2px 7px;
  margin: 5px 5px 0 0;
  line-height: 14px;
  cursor: pointer;
  opacity: 0.3;
}

.copy-code-button:hover,
.copy-code-button:focus,
.copy-code-button:active,
.copy-code-button:active:hover {
  background-color: #6fc1ff;
  border: #6fc1ff;
  opacity: 0.8;
}

.copyable-text-area {
  position: absolute;
  height: 0;
  z-index: -1;
  opacity: .01;
}
```

Did you notice that the CSS includes a selector for a `highlight-wrapper` class that is not present in the HTML structure rendered by Chroma? We will create this element and append the positioned elements as a child node, then insert the wrapper into the DOM in place of the <code class="chroma"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">"highlight"</span><span class="p">&gt;</span></code> element.

Similarly, the `copyable-text-area` class will be applied to a `textarea` element that will only exist if the Clipboard API is not available. This element will be added to the DOM and have it's value set to the `innerText` value of the `code` we wish to copy. After copying the text, the `textarea` element will be removed fom the DOM. The `height: 0` and `opacity: .01` stylings make it virtually invisible.

With that in mind, let's take a look at the JavaScript:

{{< highlight javascript "linenos=table" >}}function createCopyButton(highlight) {
  const button = document.createElement("button");
  button.className = "copy-code-button";
  button.type = "button";
  button.innerText = "Copy";
  button.addEventListener("click", () => copyCodeToClipboard(button, highlight));
  addCopyButtonToDom(button, highlight);
}

async function copyCodeToClipboard(button, highlight) {
  const codeElement = highlight.querySelector(":last-child > .chroma > code");
  const codeToCopy = codeElement.innerText;
  try {
    result = await navigator.permissions.query({ name: "clipboard-write" });
    if (result.state == "granted" || result.state == "prompt") {
      await navigator.clipboard.writeText(codeToCopy);
    } else {
      copyCodeBlockExecCommand(codeToCopy, highlight);
    }
    codeWasCopied(button);
  } catch (_) {
    copyCodeBlockExecCommand(codeToCopy, highlight);
    codeWasCopied(button);
  }
}

function copyCodeBlockExecCommand(codeToCopy, highlight) {
  const textArea = document.createElement("textArea");
  textArea.className = "copyable-text-area";
  textArea.value = codeToCopy;
  highlight.insertBefore(textArea, highlight.firstChild);
  textArea.select();
  document.execCommand("copy");
  highlight.removeChild(textArea);
}

function codeWasCopied(button) {
  button.blur();
  button.innerText = "Copied!";
  setTimeout(function() {
    button.innerText = "Copy";
  }, 2000);
}

function addCopyButtonToDom(button, highlight) {
  highlight.insertBefore(button, highlight.firstChild);
  const wrapper = document.createElement("div");
  wrapper.className = "highlight-wrapper";
  highlight.parentNode.insertBefore(wrapper, highlight);
  wrapper.appendChild(highlight);
}

document.querySelectorAll(".highlight")
  .forEach(highlight => createCopyButton(highlight));
{{< /highlight >}}

Most of the code is self-explanatory, however I think it's important to point out a couple of things. When the page has fully loaded, a "Copy" button is created for each <code class="chroma"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">"highlight"</span><span class="p">&gt;</span></code> element and the `copyCodeToClipboard` function is assigned as the event handler for the button's click event (**Lines 2-6**). Then, `addCopyButtonToDom` is called. Let's examine how this function works:

<div class="code-details">
    <ul>
      <li>
        <p><strong>Line 46: </strong>First, the "Copy" button is inserted into the DOM as the first child of the <code class="chroma"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">"highlight"</span><span class="p">&gt;</span></code> element.</p>
      </li>
      <li>
        <p><strong>Line 47-48: </strong>We create a <code>div</code> element to act as a wrapper for the <code class="chroma"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">"highlight"</span><span class="p">&gt;</span></code> element and assign the appropriate styling.</p>
      </li>
      <li>
        <p><strong>Line 49-50: </strong>Finally, the wrapper element is inserted into the DOM in the same location as the <code class="chroma"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">"highlight"</span><span class="p">&gt;</span></code> element, and the <code class="chroma"><span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">"highlight"</span><span class="p">&gt;</span></code> element is "wrapped" by calling <code>appendChild</code>.</p>
      </li>
    </ul>
</div>

When the user clicks a "Copy" button, the `copyCodeToClipboard` function is called. Since this is slightly unintuitive, let's go through the steps performed by this function:

<div class="code-details">
    <ul>
      <li>
        <p><strong>Lines 14-15: </strong>Within the try/catch block, we first check if the <code>clipboard-write</code> permission has been granted.</p>
      </li>
      <li>
        <p><strong>Line 16: </strong>If the browser supports the Clipboard API and the <code>clipboard-write</code> permission has been granted, the text within the code block is copied to the clipboard by calling <code>navigator.clipboard.writeText</code>.</p>
      </li>
      <li>
        <p><strong>Line 18: </strong>If the browser supports the Clipboard API but the <code>clipboard-write</code> permission <span class="emphasis">has not been granted</span>, we call <code>copyCodeBlockExecCommand</code>.</p>
      </li>
      <li>
        <p><strong>Line 20: </strong>In either case, since we are still within the <code>try</code> block (i.e., no error/exception has occurred) we call <code>codeWasCopied</code> which changes the button text to "Copied!" to notify the user that the code block was successfully copied to the clipboard. After two seconds the button text is changed back to "Copy".</p>
      </li>
      <li>
        <p><strong>Lines 22-23: </strong>If the browser <span class="emphasis">does not</span> support the Clipboard API, an error will be raised. Since this is an expected failure, within the <code>catch</code> block we call <code>copyCodeBlockExecCommand</code> followed by <code>codeWasCopied</code>.</p>
      </li>
      <li>
        <p><strong>Line 28-29: </strong>When the Clipboard API is unsupported/permission is not granted, we create a <code>textarea</code> element and assign the appropriate styling to make it hidden from the user but still available programmatically.</p>
      </li>
      <li>
        <p><strong>Line 30: </strong>We set the value of the <code>textarea</code> element to be equal the text the user wishes to copy.</p>
      </li>
      <li>
        <p><strong>Line 31: </strong>The <code>textarea</code> element is temporarily aded to the DOM next to the copy button.</p>
      </li>
      <li>
        <p><strong>Line 32-34: </strong>The <code>textarea</code> element is selected before calling <code>document.execCommand("copy")</code>, which copies the text we assigned to the <code>textarea</code> element to the clipboard. After doing so, the <code>textarea</code> element is removed from the DOM.</p>
      </li>
    </ul>
</div>

On this site, the JavaScript in the code block above lives in a file named `copyCodeBlock.js` inside the `static` folder. If you'd like, you can verify this and debug the code using your browser's dev tools on any page that contains a code block. I hope this is helpful to you if you use Hugo and have run into the same problem, please leave any feedback/questions in the comments below!
